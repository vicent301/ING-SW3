trigger:
  - main

resources:
  repositories:
    - repository: self
      type: git
      name: APP_WEB
      ref: main
      checkoutOptions:
        clean: true
        submodules: false
      path: APP_WEB

variables:
  # Service connections / Azure
  ConnectedServiceName: 'ServiceConnectionAPP'     # si tu SC real es otro, cambialo
  azureServiceConnection: 'sc-azure-appweb'
  resourceGroup: 'gr-acr-app'

  # ACR
  acrName: 'acreccommerce'
  acrLoginServer: 'acreccommerce.azurecr.io'

  # Nombres de imágenes (repos en ACR)
  backImageName: 'appweb-cont-back'
  frontImageName: 'appweb-cont-front'

  # App Services (Web App for Containers)
  webAppApiQA: 'cont-api-qa'
  webAppFrontQA: 'cont-front-qa'
  webAppApiPROD: 'cont-api-prod'
  webAppFrontPROD: 'cont-front-prod'

  buildConfiguration: 'Release'
  TEST_PASSWORD: "test-password-ci"
  imageTag: 'v$(Build.BuildId)'

stages:
  # =========================
  # 0) TESTS FRONTEND + BACKEND + E2E
  # =========================
  - stage: Frontend_Backend_Tests
    displayName: "Test Front + Back + E2E"
    jobs:
      # ---------- FRONTEND ----------
      - job: RunFrontendTests
        displayName: "Pruebas Frontend"
        pool: { vmImage: "ubuntu-latest" }
        steps:
          - checkout: self
            clean: true
            persistCredentials: true

          - task: NodeTool@0
            inputs: { versionSpec: "20.x" }

          - script: |
              set -euo pipefail
              cd frontend
              npm ci
              npx vitest run --coverage --reporter=junit --outputFile test-results.xml
            displayName: "Run Vitest + coverage (Istanbul)"

          - task: PublishTestResults@2
            displayName: "Publicar tests Frontend (JUnit)"
            inputs:
              testResultsFormat: "JUnit"
              testResultsFiles: "frontend/test-results.xml"
              testRunTitle: "Vitest"
              failTaskOnFailedTests: true
            condition: succeededOrFailed()

          - task: PublishCodeCoverageResults@2
            displayName: "Publicar coverage Frontend"
            inputs:
              codeCoverageTool: "Cobertura"
              summaryFileLocation: "$(System.DefaultWorkingDirectory)/frontend/coverage/cobertura-coverage.xml"
              reportDirectory: "$(System.DefaultWorkingDirectory)/frontend/coverage"
              failIfCoverageEmpty: false
            condition: succeededOrFailed()

          - task: PublishBuildArtifacts@1
            displayName: "Artefacto: coverage HTML Front"
            inputs:
              ArtifactName: "coverage-front"
              PathtoPublish: "frontend/coverage"

      # ---------- E2E CYPRESS ----------
      - job: RunCypressE2E
        displayName: "E2E Cypress (QA baseUrl)"
        pool: { vmImage: "ubuntu-latest" }
        steps:
          - checkout: self
            clean: true
            persistCredentials: true

          - task: NodeTool@0
            inputs: { versionSpec: "20.x" }

          - script: |
              cd frontend
              npm ci
              CYPRESS_BASE_URL="https://appweb-front-qa-ctg3cwawggeag6g4.northcentralus-01.azurewebsites.net" \
              npx cypress run
            displayName: "Run Cypress headless (baseUrl QA)"

          - script: |
              mkdir -p "$(System.DefaultWorkingDirectory)/frontend/cypress/videos"
              mkdir -p "$(System.DefaultWorkingDirectory)/frontend/cypress/screenshots"
            displayName: "Asegurar carpetas Cypress"
            condition: always()

          - task: PublishTestResults@2
            displayName: "Publicar resultados E2E (JUnit)"
            inputs:
              testResultsFormat: "JUnit"
              testResultsFiles: "frontend/cypress/results/*.xml"
              testRunTitle: "Cypress E2E"
            condition: succeededOrFailed()

          - task: PublishBuildArtifacts@1
            displayName: "Artefacto: Cypress videos"
            inputs:
              ArtifactName: "cypress-videos"
              PathtoPublish: "$(System.DefaultWorkingDirectory)/frontend/cypress/videos"
            condition: always()

          - task: PublishBuildArtifacts@1
            displayName: "Artefacto: Cypress screenshots"
            inputs:
              ArtifactName: "cypress-screens"
              PathtoPublish: "$(System.DefaultWorkingDirectory)/frontend/cypress/screenshots"
            condition: always()

      # ---------- BACKEND ----------
      - job: RunBackendTests
        displayName: "Pruebas Backend"
        pool: { vmImage: "ubuntu-latest" }
        steps:
          - checkout: self
            clean: true
            persistCredentials: true

          - task: GoTool@0
            inputs: { version: '1.24.8' }

          - script: |
              set -euo pipefail
              cd backend

              go install github.com/jstemmer/go-junit-report@latest
              go install github.com/boumenot/gocover-cobertura@latest
              export GOPATH="$(go env GOPATH)"
              export PATH="$GOPATH/bin:$PATH"

              PKGS="$(go list ./... \
                  | grep -v -E 'backend/tests/mocks|backend/testutil' \
                  | grep -v -E '^backend$' \
                  | tr '\n' ' ')"
              COVERPKG="$(echo "$PKGS" | tr ' ' ',' )"

              echo "PKGS=$PKGS"
              echo "COVERPKG=$COVERPKG"

              go test -v -covermode=atomic -coverpkg="$COVERPKG" $PKGS -coverprofile=coverage.out | tee test.out
              cat test.out | go-junit-report > junit-backend.xml

              gocover-cobertura < coverage.out > cobertura.xml
              go tool cover -html=coverage.out -o coverage.html
            displayName: "Run go test (filtered coverpkg)"

          - task: PublishTestResults@2
            displayName: "Publicar tests Backend (JUnit)"
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: 'backend/junit-backend.xml'
              testRunTitle: 'Go Unit Tests'
              failTaskOnFailedTests: true
            condition: succeededOrFailed()

          - task: PublishCodeCoverageResults@2
            displayName: 'Publicar coverage Backend'
            inputs:
              codeCoverageTool: 'Cobertura'
              summaryFileLocation: '$(System.DefaultWorkingDirectory)/backend/cobertura.xml'
              reportDirectory: '$(System.DefaultWorkingDirectory)/backend'
              failIfCoverageEmpty: false
            condition: succeededOrFailed()

          - task: PublishBuildArtifacts@1
            displayName: "Artefacto: coverage HTML Back"
            inputs:
              ArtifactName: 'coverage-back'
              PathtoPublish: '$(System.DefaultWorkingDirectory)/backend/coverage.html'

  # =========================
  # 1) ANALISIS ESTATICO (SonarCloud)
  # =========================
  - stage: Static_Analysis_SonarCloud
    displayName: "Static Analysis (SonarCloud)"
    dependsOn: Frontend_Backend_Tests
    condition: succeeded()
    jobs:
      - job: SonarAnalysis
        displayName: "Run SonarCloud + Quality Gate"
        pool: { vmImage: 'ubuntu-latest' }
        steps:
          - checkout: self
            clean: true
            persistCredentials: true
            fetchDepth: 0

          - task: SonarCloudPrepare@2
            displayName: "SonarCloud Prepare"
            inputs:
              SonarCloud: 'SonarClound'   # <- usando tu service connection EXACTO
              organization: 'simons15'
              scannerMode: 'CLI'
              configMode: 'manual'
              cliProjectKey: 'simons15_api_ecommerce'
              cliProjectName: 'api_ecommerce'

          - task: SonarCloudAnalyze@2
            displayName: "Run Sonar Analysis"

          - task: SonarCloudPublish@2
            displayName: "Publish Sonar Results (Quality Gate)"
            inputs:
              pollingTimeoutSec: '300'

  # =========================
  # 2) (Opcional) BUILD ZIPS (no usados por contenedores, lo dejo por compatibilidad)
  # =========================
  - stage: Build
    displayName: "Build Front + Back"
    dependsOn: Static_Analysis_SonarCloud
    condition: succeeded()
    jobs:
      - job: BuildJob
        pool: { vmImage: 'ubuntu-latest' }
        steps:
          # --- Backend (Go) ---
          - task: GoTool@0
            inputs: { version: '1.24.8' }
          - script: |
              cd backend
              go mod download
              go build -o appweb-backend
            displayName: 'Build Go backend'

          - task: ArchiveFiles@2
            inputs:
              rootFolderOrFile: 'backend'
              includeRootFolder: false
              archiveType: 'zip'
              archiveFile: '$(Build.ArtifactStagingDirectory)/backend.zip'
            displayName: 'Empaquetar backend'

          # --- Frontend (Vite) ---
          - task: NodeTool@0
            inputs: { versionSpec: '20.x' }
          - script: |
              cd frontend
              npm ci
              VITE_API_URL=https://appweb-api-qa-cjc6b0hpbkbxgvf6.northcentralus-01.azurewebsites.net/api npm run build
            displayName: 'Build Front en Vite'

          - task: ArchiveFiles@2
            inputs:
              rootFolderOrFile: 'frontend/dist'
              includeRootFolder: false
              archiveType: 'zip'
              archiveFile: '$(Build.ArtifactStagingDirectory)/frontend.zip'
            displayName: 'Empaquetar frontend'

          - task: PublishBuildArtifacts@1
            inputs:
              ArtifactName: 'drop'
              PathtoPublish: '$(Build.ArtifactStagingDirectory)'
            displayName: 'Publicar artefactos'

  # =========================
  # 3) DOCKER BUILD & PUSH (BACK + FRONT)
  # =========================
  - stage: DockerBuildAndPush
    displayName: 'Construir y Subir Imágenes Docker a ACR'
    dependsOn: Build
    jobs:
      - job: docker_build_and_push
        displayName: 'Docker build & push'
        pool: { vmImage: 'ubuntu-latest' }
        steps:
          - checkout: self

          - task: AzureCLI@2
            displayName: 'Login ACR'
            inputs:
              azureSubscription: '$(ConnectedServiceName)'
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                az acr login --name $(acrName)

          # Backend
          - task: Docker@2
            displayName: 'Build imagen Backend'
            inputs:
              command: build
              repository: $(acrLoginServer)/$(backImageName)
              dockerfile: $(Build.SourcesDirectory)/docker/api/Dockerfile
              buildContext: $(Build.SourcesDirectory)/backend
              tags: |
                $(imageTag)
                qa
                prod

          - task: Docker@2
            displayName: 'Push imagen Backend'
            inputs:
              command: push
              repository: $(acrLoginServer)/$(backImageName)
              tags: |
                $(imageTag)
                qa
                prod

          # Frontend
          - task: Docker@2
            displayName: 'Build imagen Frontend'
            inputs:
              command: build
              repository: $(acrLoginServer)/$(frontImageName)
              dockerfile: $(Build.SourcesDirectory)/docker/front/Dockerfile
              buildContext: $(Build.SourcesDirectory)/frontend
              tags: |
                $(imageTag)
                qa
                prod

          - task: Docker@2
            displayName: 'Push imagen Frontend'
            inputs:
              command: push
              repository: $(acrLoginServer)/$(frontImageName)
              tags: |
                $(imageTag)
                qa
                prod

  # =========================
  # 4) DEPLOY QA — Web App for Containers
  # =========================
  - stage: Deploy_QA
    displayName: "Deploy QA"
    dependsOn: DockerBuildAndPush
    variables:
      - group: VG_QA   # Debe contener: DB_HOST, DB_PORT, DB_NAME, DB_USER, DB_PASSWORD, API_URL
    jobs:
      - deployment: QADeploy
        displayName: 'Deploy a QA'
        environment: 'QA'
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self

                # BACKEND QA: imagen + app settings
                - task: AzureCLI@2
                  displayName: 'Configurar Backend QA (imagen + env)'
                  inputs:
                    azureSubscription: '$(azureServiceConnection)'
                    scriptType: bash
                    scriptLocation: inlineScript
                    inlineScript: |
                      az webapp config container set \
                        --name $(webAppApiQA) \
                        --resource-group $(resourceGroup) \
                        --docker-custom-image-name $(acrLoginServer)/$(backImageName):qa \
                        --docker-registry-server-url https://$(acrLoginServer) \
                        --docker-registry-server-user $(acrName) \
                        --docker-registry-server-password $(az acr credential show --name $(acrName) --query "passwords[0].value" -o tsv)

                      az webapp config appsettings set \
                        --name $(webAppApiQA) \
                        --resource-group $(resourceGroup) \
                        --settings \
                          DB_HOST=$(DB_HOST) \
                          DB_PORT=$(DB_PORT) \
                          DB_NAME=$(DB_NAME) \
                          DB_USER=$(DB_USER) \
                          DB_PASSWORD=$(DB_PASSWORD) \
                          PORT=8080

                # Health check backend QA
                - script: |
                    BACK_URL="https://cont-api-qa-csgneycheuckhnbh.chilecentral-01.azurewebsites.net/api/healthz"
                    echo "Checking $BACK_URL"
                    for i in {1..15}; do
                      code=$(curl -s -o /dev/null -w "%{http_code}" "$BACK_URL")
                      echo "Intento $i => $code"
                      if [ "$code" = "200" ]; then
                        exit 0
                      fi
                      sleep 5
                    done
                    echo "Health check backend FAILED"
                    exit 1
                  displayName: 'Health check Backend QA'

                # FRONTEND QA: imagen + API_URL
                - task: AzureCLI@2
                  displayName: 'Configurar Frontend QA (imagen + API_URL)'
                  inputs:
                    azureSubscription: '$(azureServiceConnection)'
                    scriptType: bash
                    scriptLocation: inlineScript
                    inlineScript: |
                      az webapp config container set \
                        --name $(webAppFrontQA) \
                        --resource-group $(resourceGroup) \
                        --docker-custom-image-name $(acrLoginServer)/$(frontImageName):qa \
                        --docker-registry-server-url https://$(acrLoginServer) \
                        --docker-registry-server-user $(acrName) \
                        --docker-registry-server-password $(az acr credential show --name $(acrName) --query "passwords[0].value" -o tsv)

                      az webapp config appsettings set \
                        --name $(webAppFrontQA) \
                        --resource-group $(resourceGroup) \
                        --settings API_URL="https://$(webAppApiQA).azurewebsites.net"

  # =========================
  # 5) DEPLOY PROD — Web App for Containers (aprobación en Environment)
  # =========================
  - stage: Deploy_Prod
    displayName: "Deploy Producción"
    dependsOn: Deploy_QA
    variables:
      - group: VG_PROD   # Debe contener: DB_* y API_URL de producción (si preferís, podés setear URL explícita)
    jobs:
      - deployment: ProdDeploy
        displayName: 'Deploy a Producción'
        environment: 'Production'
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self

                # BACKEND PROD
                - task: AzureCLI@2
                  displayName: 'Configurar Backend PROD (imagen + env)'
                  inputs:
                    azureSubscription: '$(azureServiceConnection)'
                    scriptType: bash
                    scriptLocation: inlineScript
                    inlineScript: |
                      az webapp config container set \
                        --name $(webAppApiPROD) \
                        --resource-group $(resourceGroup) \
                        --docker-custom-image-name $(acrLoginServer)/$(backImageName):prod \
                        --docker-registry-server-url https://$(acrLoginServer) \
                        --docker-registry-server-user $(acrName) \
                        --docker-registry-server-password $(az acr credential show --name $(acrName) --query "passwords[0].value" -o tsv)

                      az webapp config appsettings set \
                        --name $(webAppApiPROD) \
                        --resource-group $(resourceGroup) \
                        --settings \
                          DB_HOST=$(DB_HOST) \
                          DB_PORT=$(DB_PORT) \
                          DB_NAME=$(DB_NAME) \
                          DB_USER=$(DB_USER) \
                          DB_PASSWORD=$(DB_PASSWORD) \
                          PORT=8080

                - script: |
                    BACK_URL="https://cont-api-prod-hqgzgzb2cdbegdag.chilecentral-01.azurewebsites.net/api/healthz"
                    echo "Checking $BACK_URL"
                    for i in {1..15}; do
                      code=$(curl -s -o /dev/null -w "%{http_code}" "$BACK_URL")
                      echo "Intento $i => $code"
                      if [ "$code" = "200" ]; then
                        exit 0
                      fi
                      sleep 5
                    done
                    echo "Health check backend PROD FAILED"
                    exit 1
                  displayName: 'Health check Backend PROD'

                # FRONTEND PROD
                - task: AzureCLI@2
                  displayName: 'Configurar Frontend PROD (imagen + API_URL)'
                  inputs:
                    azureSubscription: '$(azureServiceConnection)'
                    scriptType: bash
                    scriptLocation: inlineScript
                    inlineScript: |
                      az webapp config container set \
                        --name $(webAppFrontPROD) \
                        --resource-group $(resourceGroup) \
                        --docker-custom-image-name $(acrLoginServer)/$(frontImageName):prod \
                        --docker-registry-server-url https://$(acrLoginServer) \
                        --docker-registry-server-user $(acrName) \
                        --docker-registry-server-password $(az acr credential show --name $(acrName) --query "passwords[0].value" -o tsv)

                      az webapp config appsettings set \
                        --name $(webAppFrontPROD) \
                        --resource-group $(resourceGroup) \
                        --settings API_URL="https://$(webAppApiPROD).azurewebsites.net"
