trigger:
  - main

resources:
  repositories:
    - repository: self
      type: git
      name: APP_WEB
      ref: main
      checkoutOptions:
        clean: true
        submodules: false
      path: APP_WEB

variables:
  buildConfiguration: 'Release'

stages:
  # =========================
  # 0) TESTS FRONTEND + BACKEND + E2E (coverage sin umbral)
  # =========================
  - stage: Frontend_Backend_Tests
    displayName: "Test Front + Back + E2E"
    jobs:
      # ---------- FRONTEND ----------
      - job: RunFrontendTests
        displayName: "Pruebas Frontend"
        pool:
          vmImage: "ubuntu-latest"
        steps:
          - checkout: self
            clean: true
            persistCredentials: true

          - task: NodeTool@0
            inputs:
              versionSpec: "20.x"

          - script: |
              set -euo pipefail
              cd frontend
              npm ci
              # Vitest con cobertura (Istanbul) + reporte JUnit
              npx vitest run --coverage --reporter=junit --outputFile test-results.xml
            displayName: "Run Vitest + coverage (Istanbul)"

          - task: PublishTestResults@2
            displayName: "Publicar tests Frontend (JUnit)"
            inputs:
              testResultsFormat: "JUnit"
              testResultsFiles: "frontend/test-results.xml"
              testRunTitle: "Vitest"
              failTaskOnFailedTests: true
            condition: succeededOrFailed()

          - task: PublishCodeCoverageResults@2
            displayName: "Publicar coverage Frontend"
            inputs:
              codeCoverageTool: "Cobertura"
              summaryFileLocation: "$(System.DefaultWorkingDirectory)/frontend/coverage/cobertura-coverage.xml"
              reportDirectory: "$(System.DefaultWorkingDirectory)/frontend/coverage"
              failIfCoverageEmpty: false
            condition: succeededOrFailed()

          - task: PublishBuildArtifacts@1
            displayName: "Artefacto: coverage HTML Front"
            inputs:
              ArtifactName: "coverage-front"
              PathtoPublish: "frontend/coverage"

      # ---------- BACKEND ----------
      - job: RunBackendTests
        displayName: "Pruebas Backend"
        pool:
          vmImage: "ubuntu-latest"
        steps:
          - checkout: self
            clean: true
            persistCredentials: true

          - task: GoTool@0
            inputs:
              version: '1.21.6'

          - script: |
              set -euo pipefail
              cd backend
              go mod download
              
              # Herramientas para JUnit y Cobertura
              go install github.com/jstemmer/go-junit-report@latest
              go install github.com/boumenot/gocover-cobertura@latest
              
                # A帽adir GOPATH/bin al PATH para invocar los binarios
              export GOPATH="$(go env GOPATH)"
              export PATH="$GOPATH/bin:$PATH"

              # Ejecutar tests con cobertura y generar JUnit
              go test ./... -v -covermode=atomic -coverprofile=coverage.out | go-junit-report > junit-backend.xml

              # coverprofile -> Cobertura XML
              gocover-cobertura < coverage.out > cobertura.xml

              # HTML de cobertura para inspecci贸n
              go tool cover -html=coverage.out -o coverage.html
            displayName: "Run go test + coverage"

          - task: PublishTestResults@2
            displayName: "Publicar tests Backend (JUnit)"
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: 'backend/junit-backend.xml'
              testRunTitle: 'Go Unit Tests'
              failTaskOnFailedTests: true
            condition: succeededOrFailed()

          - task: PublishCodeCoverageResults@2
            displayName: 'Publicar coverage Backend'
            inputs:
              codeCoverageTool: 'Cobertura'
              summaryFileLocation: '$(System.DefaultWorkingDirectory)/backend/cobertura.xml'
              reportDirectory: '$(System.DefaultWorkingDirectory)/backend'
              failIfCoverageEmpty: false
            condition: succeededOrFailed()

          - task: PublishBuildArtifacts@1
            displayName: "Artefacto: coverage HTML Back"
            inputs:
              ArtifactName: 'coverage-back'
              PathtoPublish: '$(System.DefaultWorkingDirectory)/backend/coverage.html'

      # ---------- E2E CYPRESS ----------
      - job: RunCypressE2E
        displayName: "E2E Cypress (QA baseUrl)"
        pool:
          vmImage: "ubuntu-latest"
        steps:
          - checkout: self
            clean: true
            persistCredentials: true

          - task: NodeTool@0
            inputs:
              versionSpec: "20.x"

          - script: |
              cd frontend
              npm ci
              # Ejecutar Cypress en modo headless apuntando a QA
              CYPRESS_BASE_URL="https://appweb-front-qa-ctg3cwawggeag6g4.northcentralus-01.azurewebsites.net" \
              npx cypress run
            displayName: "Run Cypress headless (baseUrl QA)"

          # --- Opci贸n B: Crear carpetas siempre para evitar errores ---
          - script: |
              mkdir -p "$(System.DefaultWorkingDirectory)/frontend/cypress/videos"
              mkdir -p "$(System.DefaultWorkingDirectory)/frontend/cypress/screenshots"
            displayName: "Asegurar carpetas Cypress"
            condition: always()

          - task: PublishTestResults@2
            displayName: "Publicar resultados E2E (JUnit)"
            inputs:
              testResultsFormat: "JUnit"
              testResultsFiles: "frontend/cypress/results/*.xml"
              testRunTitle: "Cypress E2E"
            condition: succeededOrFailed()

          - task: PublishBuildArtifacts@1
            displayName: "Artefacto: Cypress videos"
            inputs:
              ArtifactName: "cypress-videos"
              PathtoPublish: "$(System.DefaultWorkingDirectory)/frontend/cypress/videos"
            condition: always()

          - task: PublishBuildArtifacts@1
            displayName: "Artefacto: Cypress screenshots"
            inputs:
              ArtifactName: "cypress-screens"
              PathtoPublish: "$(System.DefaultWorkingDirectory)/frontend/cypress/screenshots"
            condition: always()
  # =========================
  # 1) ANALISIS ESTATICO (SonarCloud)
  # =========================
  - stage: Static_Analysis_SonarCloud
    displayName: "Static Analysis (SonarCloud)"
    dependsOn: Frontend_Backend_Tests
    condition: succeeded()
    jobs:
      - job: SonarAnalysis
        displayName: "Run SonarCloud + Quality Gate"
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            clean: true
            persistCredentials: true
            fetchDepth: 0   # <-- REQUERIDO por Sonar para blame

          - task: SonarCloudPrepare@2
            displayName: "SonarCloud Prepare"
            inputs:
              SonarCloud: 'SonarClound'  # Nombre de tu Service Connection
              organization: 'simons15'
              scannerMode: 'CLI'
              configMode: 'manual'
              cliProjectKey: 'simons15_api_ecommerce'
              cliProjectName: 'api_ecommerce'

          - task: SonarCloudAnalyze@2
            displayName: "Run Sonar Analysis"

          - task: SonarCloudPublish@2
            displayName: "Publish Sonar Results (Quality Gate)"
            inputs:
              pollingTimeoutSec: '300'

  # =========================
  # 2) BUILD
  # =========================
  - stage: Build
    displayName: "Build Front + Back"
    dependsOn: Static_Analysis_SonarCloud
    condition: succeeded()
    jobs:
      - job: BuildJob
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          # --- Backend (Go) ---
          - task: GoTool@0
            inputs:
              version: '1.21.6'
          - script: |
              cd backend
              go mod download
              go build -o appweb-backend
            displayName: 'Build Go backend'

          - task: ArchiveFiles@2
            inputs:
              rootFolderOrFile: 'backend'
              includeRootFolder: false
              archiveType: 'zip'
              archiveFile: '$(Build.ArtifactStagingDirectory)/backend.zip'
            displayName: 'Empaquetar backend'

          # --- Frontend (Vite) ---
          - task: NodeTool@0
            inputs:
              versionSpec: '20.x'
          - script: |
              cd frontend
              npm ci
              VITE_API_URL=https://appweb-api-qa-cjc6b0hpbkbxgvf6.northcentralus-01.azurewebsites.net/api npm run build
            displayName: 'Build Front en Vite'

          - task: ArchiveFiles@2
            inputs:
              rootFolderOrFile: 'frontend/dist'
              includeRootFolder: false
              archiveType: 'zip'
              archiveFile: '$(Build.ArtifactStagingDirectory)/frontend.zip'
            displayName: 'Empaquetar frontend'

          - task: PublishBuildArtifacts@1
            inputs:
              ArtifactName: 'drop'
              PathtoPublish: '$(Build.ArtifactStagingDirectory)'
            displayName: 'Publicar artefactos'

    # =========================
  # 3) QA
  # =========================
  - stage: Deploy_QA
    displayName: "Deploy QA"
    dependsOn: Build
    variables:
      - group: VG_QA     # <- Variable Group QA
    jobs:
      - deployment: QADeploy
        displayName: 'Deploy a QA'
        environment: 'QA'
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  clean: true
                  persistCredentials: true

                - download: current
                  artifact: drop

                # --- BACKEND QA ---
                - task: AzureWebApp@1
                  displayName: 'Deploy Backend QA'
                  inputs:
                    azureSubscription: 'sc-azure-appweb'

                    appName: '$(webAppNameBack)'
                    package: '$(Pipeline.Workspace)/drop/backend.zip'


                # Setear App Settings (DB, etc.) por si cambian
                - task: AzureAppServiceSettings@1
                  displayName: 'App Settings Backend QA'
                  inputs:
                    azureSubscription: 'sc-azure-appweb'

                    appName: '$(webAppNameBack)'
                    appSettings: |
                      [
                        {"name":"DB_HOST","value":"$(DB_HOST)","slotSetting":false},
                        {"name":"DB_PORT","value":"$(DB_PORT)","slotSetting":false},
                        {"name":"DB_NAME","value":"$(DB_NAME)","slotSetting":false},
                        {"name":"DB_USER","value":"$(DB_USER)","slotSetting":false},
                        {"name":"DB_PASSWORD","value":"$(DB_PASSWORD)","slotSetting":false},
                        {"name":"DB_SSLMODE","value":"$(DB_SSLMODE)","slotSetting":false},
                        {"name":"PORT","value":"8080","slotSetting":false}
                      ]

                # Health check backend
                - script: |
                    BACK_URL="https://appweb-api-qa-cjc6b0hpbkbxgvf6.northcentralus-01.azurewebsites.net/api/healthz"
                    echo "Checking $BACK_URL"
                    for i in {1..10}; do
                      code=$(curl -s -o /dev/null -w "%{http_code}" "$BACK_URL")
                      echo "Intento $i => $code"
                      if [ "$code" = "200" ]; then
                        exit 0
                      fi
                      sleep 5
                    done
                    echo "Health check backend FAILED"
                    exit 1
                  displayName: 'Health check Backend QA'

                # --- FRONTEND QA ---
                # Volvemos a construir el front con la variable VITE_API_URL de QA
                - task: NodeTool@0
                  inputs:
                    versionSpec: '20.x'
                - script: |
                    echo " Carpeta actual:"
                    pwd
                    echo " Contenido:"
                    ls -la
                    echo "Usando VITE_API_URL=$(VITE_API_URL)"

                    cd frontend
                    npm ci
                    VITE_API_URL=$(VITE_API_URL) npm run build
                  displayName: 'Build Vite con vars QA'



                - task: ArchiveFiles@2
                  inputs:
                    rootFolderOrFile: 'frontend/dist'
                    includeRootFolder: false
                    archiveType: 'zip'
                    archiveFile: '$(Pipeline.Workspace)/drop/frontend-qa.zip'
                  displayName: 'Empaquetar frontend QA'


                - task: AzureWebApp@1
                  displayName: 'Deploy Frontend QA'
                  inputs:
                    azureSubscription: 'sc-azure-appweb'

                    appName: '$(webAppNameFront)'
                    package: '$(Pipeline.Workspace)/drop/frontend-qa.zip'



                # Health check frontend
                - script: |
                    FRONT_URL="https://appweb-front-qa-ctg3cwawggeag6g4.northcentralus-01.azurewebsites.net/"
                    echo "Checking $FRONT_URL"
                    for i in {1..10}; do
                      code=$(curl -s -o /dev/null -w "%{http_code}" "$FRONT_URL")
                      echo "Intento $i => $code"
                      if [ "$code" = "200" ]; then
                        exit 0
                      fi
                      sleep 5
                    done
                    echo "Health check frontend FAILED"
                    exit 1
                  displayName: 'Health check Frontend QA'

  # =========================
  # 4) PRODUCCIN (con aprobaci贸n)
  # =========================
  - stage: Deploy_Prod
    displayName: "Deploy Producci贸n"
    dependsOn: Deploy_QA
    variables:
      - group: VG_PROD   # <- Variable Group PROD
    jobs:
      - deployment: ProdDeploy
        displayName: 'Deploy a Producci贸n'
        environment: 'Production'   # <- este env tiene aprobaci贸n manual
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  clean: true
                  persistCredentials: true

                - download: current
                  artifact: drop

                # BACKEND PROD
                - task: AzureWebApp@1
                  displayName: 'Deploy Backend PROD'
                  inputs:
                    azureSubscription: 'sc-azure-appweb'

                    appName: '$(webAppNameBack)'
                    package: '$(Pipeline.Workspace)/drop/backend.zip'

                - task: AzureAppServiceSettings@1
                  displayName: 'App Settings Backend PROD'
                  inputs:
                    azureSubscription: 'sc-azure-appweb'

                    appName: '$(webAppNameBack)'
                    appSettings: |
                      [
                        {"name":"DB_HOST","value":"$(DB_HOST)","slotSetting":false},
                        {"name":"DB_PORT","value":"$(DB_PORT)","slotSetting":false},
                        {"name":"DB_NAME","value":"$(DB_NAME)","slotSetting":false},
                        {"name":"DB_USER","value":"$(DB_USER)","slotSetting":false},
                        {"name":"DB_PASSWORD","value":"$(DB_PASSWORD)","slotSetting":false},
                        {"name":"DB_SSLMODE","value":"$(DB_SSLMODE)","slotSetting":false},
                        {"name":"PORT","value":"8080","slotSetting":false}
                      ]

                - script: |
                    BACK_URL="https://appweb-api-prod-hdhgb2bmb6eyaubv.chilecentral-01.azurewebsites.net/api/healthz"
                    echo "Checking $BACK_URL"
                    for i in {1..10}; do
                      code=$(curl -s -o /dev/null -w "%{http_code}" "$BACK_URL")
                      echo "Intento $i => $code"
                      if [ "$code" = "200" ]; then
                        exit 0
                      fi
                      sleep 5
                    done
                    echo "Health check backend PROD FAILED"
                    exit 1
                  displayName: 'Health check Backend PROD'


                # FRONTEND PROD (rebuild con URL de PROD)
                - task: NodeTool@0
                  inputs:
                    versionSpec: '20.x'
                - script: |
                    cd frontend
                    echo "Usando VITE_API_URL=$(VITE_API_URL)"
                    npm ci
                    VITE_API_URL=$(VITE_API_URL) npm run build
                  displayName: 'Build Vite con vars PROD'


                - task: ArchiveFiles@2
                  inputs:
                    rootFolderOrFile: 'frontend/dist'
                    includeRootFolder: false
                    archiveType: 'zip'
                    archiveFile: '$(Pipeline.Workspace)/drop/frontend-prod.zip'
                  displayName: 'Empaquetar frontend PROD'

                - task: AzureWebApp@1
                  displayName: 'Deploy Frontend PROD'
                  inputs:
                    azureSubscription: 'sc-azure-appweb'

                    appName: '$(webAppNameFront)'
                    package: '$(Pipeline.Workspace)/drop/frontend-prod.zip'

                - script: |
                    FRONT_URL="https://appweb-front-prod-h7htdzbchbhsf6g2.northcentralus-01.azurewebsites.net/"
                    echo "Checking $FRONT_URL"
                    for i in {1..10}; do
                      code=$(curl -s -o /dev/null -w "%{http_code}" "$FRONT_URL")
                      echo "Intento $i => $code"
                      if [ "$code" = "200" ]; then
                        exit 0
                      fi
                      sleep 5
                    done
                    echo "Health check frontend PROD FAILED"
                    exit 1
                  displayName: 'Health check Frontend PROD'
